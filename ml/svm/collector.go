// Copyright 2015 The dpar Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package svm

import (
	"github.com/danieldk/dpar/features/symbolic"
	"github.com/danieldk/dpar/system"
	golinear "gopkg.in/danieldk/golinear.v1"
)

// A GoLinearCollector is a training instance collector that can return
// the instances as a golinear problem. The golinear problem can be used
// to train a linear classifier.
type GoLinearCollector interface {
	system.InstanceCollector
	Problem() *golinear.Problem
}

var _ GoLinearCollector = &HashCollector{}

// HashCollector is a training instance collector for hash kernels. Since
// HashCollector implements the GoLinearCollector interface, it can be used
// to train a linear model using golinear after collection.
type HashCollector struct {
	labelNumberer    system.LabelNumberer
	featureGenerator symbolic.FeatureGenerator
	featureHash      symbolic.FeatureHashFun
	problem          *golinear.Problem
	maxFeatures      uint
}

// NewHashCollector returns a HashCollector. It requires a feature generator
// (typically an aggregate generator that combines different feature generators),
// a function for feature hashing, and the maximum number of features that can
// be generated by the hash kernel.
func NewHashCollector(featureGenerator symbolic.FeatureGenerator,
	featureHash symbolic.FeatureHashFun, maxFeatures uint) *HashCollector {
	return &HashCollector{
		labelNumberer:    system.NewLabelNumberer(),
		featureGenerator: featureGenerator,
		featureHash:      featureHash,
		problem:          golinear.NewProblem(),
		maxFeatures:      maxFeatures,
	}
}

// Collect a training instance. A training instance consists of a transition
// (which is a label) and a parser configuration. The collector extracts features
// from the parsing configuration.
func (hc *HashCollector) Collect(t system.Transition, c *system.Configuration) {
	label := hc.labelNumberer.Number(t)
	vecBuilder := newGoLinearVectorBuilder()
	hc.featureGenerator.Generate(c, hc.featureHash, vecBuilder)

	featuresByIndex := make(map[int]float64)

	for _, fv := range vecBuilder.Build() {
		hash := fv.Index

		sign := 1.
		if hash&0x80000000 == 0x80000000 {
			sign = -1
		}

		fv.Index = ((hash & 0x7fffffff) % int(hc.maxFeatures)) + 1
		fv.Value *= sign

		if val, ok := featuresByIndex[fv.Index]; ok {
			featuresByIndex[fv.Index] = val + fv.Value
		} else {
			featuresByIndex[fv.Index] = fv.Value
		}
	}

	features := make([]golinear.FeatureValue, 0, len(featuresByIndex))
	for idx, val := range featuresByIndex {
		features = append(features, golinear.FeatureValue{
			Index: idx,
			Value: val,
		})
	}

	hc.problem.Add(golinear.TrainingInstance{Label: float64(label), Features: features})
}

// Problem returns the collected training instances as a golinear problem.
func (hc *HashCollector) Problem() *golinear.Problem {
	return hc.problem
}

// LabelNumberer returns the label (transition) <=> number bijection.
func (hc *HashCollector) LabelNumberer() *system.LabelNumberer {
	return &hc.labelNumberer
}
